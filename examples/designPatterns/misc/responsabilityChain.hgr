"""
 Chain of Responsibility Design Pattern

 Author: Irwin Rodr√≠guez <rodriguez.irwin@gmail.com>
 Date: 2023-02-27
"""

#-------------------------------------------------#
# Base middleware class
#-------------------------------------------------#
declare lcMiddleware
    oNext = null

    # Builds chains of middleware objects
    fLink(poFirst, ...paChain)
        declare loHead = poFirst

        for each lvNextInChain in paChain
            loHead.oNext = lvNextInChain
            loHead = lvNextInChain
        end
        return poFirst
    end

    # Subclasses will implement this method with concrete checks.
    -fCheck(psEmail, psPassword)

    # Runs check on the next object in chain or ends traversing if we're in
    # last object in chain.
    fCheckNext(psEmail, psPassword)
        if oNext == null
            return true
        end
        return oNext.fCheck(psEmail, psPassword)
    end
end

#-------------------------------------------------#
# ConcreteHandler. Checks a user's role
#-------------------------------------------------#
declare lcRoleCheckMiddleware as lcMiddleware
    fCheck(psEmail, psPassword)
        if psEmail == "admin@example.com"
            println("Hello, admin!")
            return true
        end
        println("Hello, user!")
        return fCheckNext(psEmail, psPassword)        
    end
end

#---------------------------------------------------------------------------#
# ConcreteHandler. Checks whether there are too many failed login requests.
#---------------------------------------------------------------------------#
declare lcThrottlingMiddleware as lcMiddleware
    nRequestPerMinute = 0
    nRequest = 0
    nCurrentTime = 0

    pInit(pnRequestPerMinute)
        nRequestPerMinute = pnRequestPerMinute
        nCurrentTime = seconds()
    end

    """
        Please, note that fCheckNext() call can be inserted both in the beginning
        of this method and in the end.

        This gives much more flexibility than a simple loop over all middleware
        objects. For instance, an element of a chain ca change the order of
        checks by running its check after all other checks.
    """
    fCheck(psEmail, psPassword)
        if seconds() > nCurrentTime + 60000
            nRequest = 0
            nCurrentTime = seconds()
        end
        nRequest += 1
        if nRequest > nRequestPerMinute
            println("Request limit exceeded!")
            return false
        end
        return fCheckNext(psEmail, psPassword)
    end
end

#---------------------------------------------------------------------------#
# ConcreteHandler. Checks whether a user with the given credentials exists.
#---------------------------------------------------------------------------#
declare lcUserExistsMiddleware as lcMiddleware
    oServer = null
    pInit(poServer)
        oServer = poServer    
    end

    fCheck(psEmail, psPassword)
        if not oServer.fHasEmail(psEmail)
            println("This email is not registered!")
            return false
        end
        if not oServer.fIsValidPassword(psEmail, psPassword)
            println("Wrong password!")
            return false
        end
        return fCheckNext(psEmail, psPassword)
    end
end

#-------------------------------------------------#
# Server class
#-------------------------------------------------#
declare lcServer
    mUsers = {}
    oMiddleware = null

    # Client passes a chain of object to server. This improves flexibility and
    # makes testing the server class easier.
    pSetMiddleware(poMiddleware)
        oMiddleware = poMiddleware
    end

    # Server gets email and password from client and sends the authorization
    # request to the chain.
    fLogin(psEmail, psPassword)
        if oMiddleware.fCheck(psEmail, psPassword)
            println("Authorization have been successful!")
            # Do something useful here for authorized users.
            return true
        end
        return false
    end

    pRegister(psEmail, psPassword)
        mUsers.put(psEmail, psPassword)
    end

    fHasEmail(psEmail)
        return mUsers.contains(psEmail)
    end

    fIsValidPassword(psEmail, psPassword)
        return mUsers.get(psEmail) == psPassword
    end
end

#-------------------------------------------------#
# Client code
#-------------------------------------------------#
declare lfInit
    declare loServer = new lcServer()
    loServer.pRegister("admin@example.com", "admin_pass")
    loServer.pRegister("user@example.com", "user_pass")

    # All checks are linked. Client can build various chains using the same
    # components.
    declare loMiddleware = new lcMiddleware().fLink(
        new lcThrottlingMiddleware(2),
        new lcUserExistsMiddleware(loServer),
        new lcRoleCheckMiddleware()
    )

    # Server gets a chain from client code.
    loServer.pSetMiddleware(loMiddleware)

    return loServer
end

#-------------------------------------------------#
# Main procedure
#-------------------------------------------------#
declare lpMain
    declare loServer = lfInit()

    declare lbSuccess = false;

    repeat
        declare lsEmail = readln("Enter email: ")
        declare lsPassword = readln("Input password: ")
        lbSuccess = loServer.fLogin(lsEmail, lsPassword)
    until not lbSuccess
end

lpMain()